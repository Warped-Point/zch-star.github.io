<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    模板 | zch-star 的博客
</title>
<link rel="shortcut icon" href="https://zch-star.github.io/favicon.ico?v=1614145079725">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zch-star.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://zch-star.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://zch-star.github.io">
                <img class="avatar" src="https://zch-star.github.io/images/avatar.png?v=1614145079725" alt="">
            </a>
            <div class="site-title">
                <h1>
                    zch-star 的博客
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        模板</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://zch-star.github.io/post/oi-zhi-shi-shu/">
                        OI 知识树
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-02-24</time>
                    
                        <a href="https://zch-star.github.io/tag/6rUcgoilX/" class="post-tag i-tag
                            i-tag-other_3">
            #模板
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            『OI  知识树』\huge\color{RoyalBlue}\mathcal{『OI\thickspace知识树』}『OI知识树』

一、数据结构\Large\color{LimeGreen}\mathsf{一、数据结构}一、数据结构


栈


单调栈
$ \diamond$ 例题：P5788 【模板】单调栈
$ \diamond$ 代码：
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;
const int MAXN = 3e6;
int n, top = 0, a[MAXN + 5], f[MAXN + 5], q[MAXN + 5];
int main() {
	cin &amp;gt;&amp;gt; n;
	for (int i = 1; i &amp;lt;= n; i++) cin &amp;gt;&amp;gt; a[i];
	for (int i = 1; i &amp;lt;= n; i++) {
		while (top &amp;gt; 0 &amp;amp;&amp;amp; a[q[top]] &amp;lt; a[i]) f[q[top]] = i, top--;
		top++; q[top] = i;
	}
	for (int i = 1; i &amp;lt;= n; i++) cout &amp;lt;&amp;lt; f[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
	return 0;
}








队列


优先队列
$ \diamond$ 例题：P1090 [NOIP2004 提高组] 合并果子
$ \diamond$ 代码：
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n, x, ans;
priority_queue &amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt;q;
int main() {
	cin &amp;gt;&amp;gt; n;
	for (int i = 1; i &amp;lt;= n; i++) cin &amp;gt;&amp;gt; x, q.push(x);
	while (q.size() &amp;gt;= 2){
		int a = q.top(); q.pop();
		int b = q.top(); q.pop();
		ans += a + b;
		q.push(a + b);
	}
	cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
	return 0;
}



单调队列
$ \diamond$ 例题：P1440 求m区间内的最小值
$ \diamond$ 代码：
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n, m, a[2000010], head, tail;
struct Node {
	int data, num;
} q[2000010];
int main() {
	scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
	for (int i = 1; i &amp;lt;= n; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i]);
	printf(&amp;quot;0\n&amp;quot;);
	head++, q[head].data = a[1], q[head].num = 1; tail++;
	for (int i = 2; i &amp;lt;= n; i++) {
		while (i - q[head].num &amp;gt; m) head++;
		printf(&amp;quot;%d\n&amp;quot;, q[head].data);
		while (q[tail].data &amp;gt; a[i] &amp;amp;&amp;amp; tail &amp;gt;= head) tail--;
		tail++; q[tail].data = a[i]; q[tail].num = i;
	}
	return 0;
}



双端队列
$ \diamond$ 例题：P2032 扫描
$ \diamond$ 代码：
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n, m, a[2000010], head, tail;
struct Node {
	int data, num;
} q[2000010];
int main() {
	scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
	for (int i = 1; i &amp;lt;= n; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i]);
	head++, q[head].data = a[1], q[head].num = 1; tail++;
	for (int i = 2; i &amp;lt;= n; i++) {
		while (i - q[head].num &amp;gt;= m) head++;
		while (q[tail].data &amp;lt; a[i] &amp;amp;&amp;amp; tail &amp;gt;= head) tail--;
		tail++; q[tail].data = a[i]; q[tail].num = i;
		if (i &amp;gt;= m) printf(&amp;quot;%d\n&amp;quot;, q[head].data);
	}
	return 0;
}








堆


二叉堆
$ \diamond$ 例题：P1334 瑞瑞的木板
$ \diamond$ 代码：
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;

int n;
long long ans;
priority_queue&amp;lt; ll, vector&amp;lt;ll&amp;gt;, greater&amp;lt;ll&amp;gt; &amp;gt; a;

static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
	ll res=0,w=0;
	char c=gc;
	while (!isdigit(c)) w|=c==&#39;-&#39;,c=gc;
	while (isdigit(c)) res=(res&amp;lt;&amp;lt;1)+(res&amp;lt;&amp;lt;3)+(c^48),c=gc;
	if (w) res=-res;
	return res;
}

inline void write(ll x) {
	static int sta[50],top=0;
	if (x&amp;lt;0) putchar(&#39;-&#39;),x=-x;
	do {
		sta[top++]=x%10,x/=10;
	}while (x);
	while (top) putchar(sta[--top]+48);
	putchar(&#39;\n&#39;);
}

signed main() {
// 	IOS;
	n = read();
	for (register int i = 1; i &amp;lt;= n; ++i) {
		int k = read();
		a.push(k);
	}
	for (register int i = 1; i &amp;lt; n; ++i) {
		int p, q;
		p = a.top(); a.pop();
		q = a.top(); a.pop();
		ans += p + q;
		a.push(p + q);
	}
	write(ans);
	return 0;
}



左偏树
$ \diamond$ 例题：P3377 【模板】左偏树（可并堆）
$ \diamond$ 代码：
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int MAXN=100010;
int n, m, op, x, y;
int lc[MAXN], rc[MAXN], dist[MAXN], rt[MAXN];
bool tf[MAXN];
struct node
{
    int id, v;
    bool operator&amp;lt;(node x)const{return v==x.v?id&amp;lt;x.id:v&amp;lt;x.v;}
}v[MAXN];
int __Find(int x){return rt[x]==x?x:rt[x]=__Find(rt[x]);}
int __Merge(int x, int y) {
	if (!x || !y) return x + y;
	if (v[y] &amp;lt; v[x]) swap(x, y);
	rc[x] = __Merge(rc[x], y);
    if (dist[lc[x]] &amp;lt; dist[rc[x]]) swap(lc[x], rc[x]);
    dist[x] = dist[rc[x]] + 1;
    return x;
}
int main() {
	dist[0] = -1;
	scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m);
	for (int i = 1; i &amp;lt;= n; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;v[i].v), rt[i] = i, v[i].id = i;
	for (int i = 1; i &amp;lt;= m; i++) {
		scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;op, &amp;amp;x);
		if (op == 1) {
			scanf(&amp;quot;%d&amp;quot;, &amp;amp;y);
			if (tf[x] || tf[y]) continue;
			x = __Find(x); y = __Find(y);
			if (x != y) rt[x] = rt[y] = __Merge(x, y);
		}
		if (op == 2) {
			if (tf[x]) {printf(&amp;quot;-1\n&amp;quot;); continue;}
			x = __Find(x);
			printf(&amp;quot;%d\n&amp;quot;, v[x].v);
			tf[x] = true;
			rt[lc[x]] = rt[rc[x]] = rt[x] = __Merge(lc[x], rc[x]);
			lc[x] = rc[x] = dist[x] = 0;
		}
	}
	return 0;
}



斜堆
$ \diamond$ 例题：P2475 [SCOI2008]斜堆
$ \diamond$ 代码：
待占坑。








并查集


模板并查集
$ \diamond$ 例题：P1551 亲戚
$ \diamond$ 代码：
var
  f:array[0..10001] of longint;
  n,m,p,i,x,y:longint;

function find(x:longint):longint;
begin
  if f[x]=x then exit(x);
  f[x]:=find(f[x]);
  exit(f[x]);
end;

begin
  readln(n,m,p);
  for i:=1 to n do f[i]:=i;
  for i:=1 to m do
    begin
      readln(x,y);
      x:=find(x);
      y:=find(y);
      f[y]:=x;
    end;
  for i:=1 to p do
    begin
      readln(x,y);
      x:=find(x);
      y:=find(y);
      if x=y then writeln(&#39;Yes&#39;) else writeln(&#39;No&#39;);
    end;
end.



带权并查集
$ \diamond$ 例题：P2024 [NOI2001] 食物链
$ \diamond$ 代码：
待占坑。

$ \diamond$ 例题：P1525 [NOIP2010 提高组] 关押罪犯
$ \diamond$ 代码：
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int MAXN = 1e5+5;
struct Node {
	int a, b, c;
};
int n, m, f[MAXN &amp;lt;&amp;lt; 1];
Node a[MAXN];
inline int __Find(int x) {
	if (f[x] != x) f[x] = __Find(f[x]);
	return f[x];
}

typedef long long ll;
static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
	ll res=0,w=0;
	char c=gc;
	while (!isdigit(c)) w|=c==&#39;-&#39;,c=gc;
	while (isdigit(c)) res=(res&amp;lt;&amp;lt;1)+(res&amp;lt;&amp;lt;3)+(c^48),c=gc;
	if (w) res=-res;
	return res;
}
bool cmp(Node a, Node b) {
	return a.c &amp;gt; b.c;
}
int main() {
	n = read(); m = read();
	for (int i = 1; i &amp;lt;= (n &amp;lt;&amp;lt; 1); i++) f[i] = i;
	for (int i = 1; i &amp;lt;= m; i++) a[i].a = read(), a[i].b = read(), a[i].c = read();
	sort(a+1, a+m+1, cmp);
	for (int i = 1; i &amp;lt;= m; i++) {
		int fa = __Find(a[i].a);
		int fb = __Find(a[i].b);
		int ffa = __Find(a[i].a + n);
		int ffb = __Find(a[i].b + n);
		if(fa == fb) {
			printf(&amp;quot;%d\n&amp;quot;, a[i].c);
			return 0;
		}
		f[fa] = ffb;
		f[fb] = ffa;
	}
	puts(&amp;quot;0&amp;quot;);
	return 0;
}



可持久化并查集
$ \diamond$ 例题：P3402 可持久化并查集
$ \diamond$ 代码：
待占坑。








链表


双向链表
$ \diamond$ 例题：P1160 队列安排
$ \diamond$ 代码：
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;
const int MAXN = 1e5+5;
struct Node {int L, R;};
int n, m;
Node a[MAXN];

typedef long long ll;
static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
	ll res=0,w=0;
	char c=gc;
	while (!isdigit(c)) w|=c==&#39;-&#39;,c=gc;
	while (isdigit(c)) res=(res&amp;lt;&amp;lt;1)+(res&amp;lt;&amp;lt;3)+(c^48),c=gc;
	if (w) res=-res;
	return res;
}

inline void write(ll x) {
	static int sta[50],top=0;
	if (x&amp;lt;0) putchar(&#39;-&#39;),x=-x;
	do {
		sta[top++]=x%10,x/=10;
	}while (x);
	while (top) putchar(sta[--top]+48);
	putchar(&#39; &#39;);
}

inline void __addRight(int x, int pos)  {
	a[x].L = pos;
	a[a[pos].R].L = x;
	a[x].R = a[pos].R;
	a[pos].R = x;
}
inline void __addLeft(int x, int pos) {
	a[x].R = pos;
	a[a[pos].L].R = x;
	a[x].L = a[pos].L;
	a[pos].L = x;
}
inline void __Del(int x) {
	if (a[x].L == -1) return;
	a[a[x].L].R = a[x].R;
	a[a[x].R].L = a[x].L;
	a[x].L = -1;
	a[x].R = -1;
}
inline void __Go() {
	int x = a[0].R;
	while (1) {
		write(x);
		if (a[x].R == -1) break;
		x = a[x].R;
	}
}
inline void __Init() {
	for (int i = 1; i &amp;lt;= n; i++) a[i].L = a[i].R = -1;
	a[1].R = -1; a[1].L = 0; a[0].R = 1;
}
int main() {
	n = read();
	__Init();
	for (int i = 2; i &amp;lt;= n; i++) {
		int x = read(), y = read();
		if (!y) __addLeft(i, x); else __addRight(i, x);
	}
	m = read();
	for (int i = 1; i &amp;lt;= m; i++) {
		int x = read();
		__Del(x);
	}
	__Go();
	return 0;
}

$ \diamond$ 例题：P1081 [NOIP2012 提高组] 开车旅行
$ \diamond$ 代码：
待占坑。



块状链表
$ \diamond$ 例题：P4008 [NOI2003] 文本编辑器
$ \diamond$ 代码：
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
char xch,xB[1&amp;lt;&amp;lt;15],*xS=xB,*xTT=xB;
#define getc() (xS==xTT&amp;amp;&amp;amp;(xTT=(xS=xB)+fread(xB,1,1&amp;lt;&amp;lt;15,stdin),xS==xTT)?0:*xS++)
inline int read()
{
    int x=0,f=1;char ch=getc();
    while(ch&amp;lt;&#39;0&#39;|ch&amp;gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getc();}
    while(ch&amp;gt;=&#39;0&#39;&amp;amp;&amp;amp;ch&amp;lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getc();}
    return x*f;
}//为了使程序跑得更快所使用的读入优化 
const int maxn=2e3+10;
struct node{
    int nex,siz;//每一块数组的后继以及大小 
    char a[maxn&amp;lt;&amp;lt;1];
}b[maxn&amp;lt;&amp;lt;2];
int pool[maxn&amp;lt;&amp;lt;2],cnt,curpos;//内存池、指针以及当前光标位置 
inline int modi(){return pool[cnt++];}//内存分配 
inline void dele(int x){pool[--cnt]=x;}//内存回收 
inline void init()
{
    for(int i=1;i&amp;lt;(maxn&amp;lt;&amp;lt;2);++i) pool[i]=i;//维护内存池，动态分配回收内存 
    cnt=1;
    b[0].siz=0,b[0].nex=-1;//新建一个0号节点，方便操作 
}
inline void add(int x,int y,int num,char c[])//在第x块后添加一个编号为y的块，长度为num 
{
    if(y!=-1)
    {
        b[y].nex=b[x].nex,b[y].siz=num;
        memcpy(b[y].a,c,num);
    }
    b[x].nex=y;
}
inline void merge(int x,int y)//将第x块和第y块合并 
{
    memcpy(b[x].a+b[x].siz,b[y].a,b[y].siz);
    b[x].siz+=b[y].siz,b[x].nex=b[y].nex;
    dele(y);
}
inline void split(int cur,int pos)//将第cur块从pos处分割 
{
    if(cur==-1||pos==b[cur].siz) return ;
    add(cur,modi(),b[cur].siz-pos,b[cur].a+pos);
    b[cur].siz=pos;
}
inline int pos(int &amp;amp;x)//寻找当前光标所在的块和块内位置 
{
    int now=0;
    while(now!=-1&amp;amp;&amp;amp;x&amp;gt;b[now].siz) x-=b[now].siz,now=b[now].nex;
    return now;
}
inline void insert(int p,int num,char c[])//在p位置之后插入长度为num的字符串 
{
    int now=pos(p);
    split(now,p);
    int tot=0,nb,st=now;
    while(tot+maxn&amp;lt;=num)//维护块状链表平衡 
    {
        nb=modi();
        add(now,nb,maxn,c+tot);
        tot+=maxn;
        now=nb;
    }
    if(num-tot)
        nb=modi(),add(now,nb,num-tot,c+tot);
    if(b[now].siz+b[nb].siz&amp;lt;maxn&amp;amp;&amp;amp;nb!=-1)//不用对整个链表进行判断，部分maintain 
    	merge(now,nb),nb=b[now].nex;
    if(b[st].siz+b[b[st].nex].siz&amp;lt;maxn&amp;amp;&amp;amp;b[st].nex!=-1)//同理 
    	merge(st,b[st].nex);
//    maintain();
}
inline void erase(int p,int num)//在p位置之后删除长度为num的字符串
{
    int now=pos(p);
    split(now,p);
    int nex=b[now].nex;
    while(nex!=-1&amp;amp;&amp;amp;num&amp;gt;b[nex].siz)
        num-=b[nex].siz,nex=b[nex].nex;
    split(nex,num);
    nex=b[nex].nex;
    for(int i=b[now].nex;i!=nex;i=b[now].nex)
        b[now].nex=b[i].nex,dele(i);
    while(b[now].siz+b[nex].siz&amp;lt;maxn&amp;amp;&amp;amp;nex!=-1)//不用对整个链表进行判断，部分maintain 
    	merge(now,nex),nex=b[now].nex;
//    maintain();
}
char ans[20000000];
inline void get(int p,int num)//输出p位置后长度为num的字符串
{
    int cur=pos(p);
    int tot=b[cur].siz-p;
    if(num&amp;lt;tot) tot=num;
    memcpy(ans,b[cur].a+p,tot);
    int now=b[cur].nex;
    while(now!=-1&amp;amp;&amp;amp;num&amp;gt;=tot+b[now].siz)
    {
        memcpy(ans+tot,b[now].a,b[now].siz);
        tot+=b[now].siz,now=b[now].nex;
    }
    if(num-tot&amp;gt;0&amp;amp;&amp;amp;now!=-1)
        memcpy(ans+tot,b[now].a,num-tot);
    ans[num]=&#39;\0&#39;;//为了不清空，用\0结束 
    printf(&amp;quot;%s\n&amp;quot;,ans);
}
inline char opt()
{
	char c=getc();
	while(c!=&#39;M&#39;&amp;amp;&amp;amp;c!=&#39;I&#39;&amp;amp;&amp;amp;c!=&#39;D&#39;&amp;amp;&amp;amp;c!=&#39;G&#39;&amp;amp;&amp;amp;c!=&#39;P&#39;&amp;amp;&amp;amp;c!=&#39;N&#39;) c=getc();
	return c;
}//为了不与读入优化冲突 
int main()
{
//	freopen(&amp;quot;3.in&amp;quot;,&amp;quot;r&amp;quot;,stdin);
//	freopen(&amp;quot;3.ans&amp;quot;,&amp;quot;w&amp;quot;,stdout);
    init();
    int m;

    scanf(&amp;quot;%d&amp;quot;,&amp;amp;m);
    for(int i=1;i&amp;lt;=m;++i)
    {
        switch(opt())
        {
            case &#39;M&#39;:curpos=read();break;
            case &#39;I&#39;:
                int tmp;
                tmp=read();
                for(int i=0;i&amp;lt;tmp;++i)
                {
                    ans[i]=getc();
                    if(ans[i]&amp;lt;32||ans[i]&amp;gt;126) --i;
                }
                insert(curpos,tmp,ans);
                    break;
            case &#39;D&#39;:
                tmp=read();
                erase(curpos,tmp);
                break;
            case &#39;G&#39;:
                tmp=read();
                get(curpos,tmp);
                break;
            case &#39;P&#39;:--curpos;break;
            case &#39;N&#39;:++curpos;break;
        }
    }
    return 0;
}








树状数组


求逆序对
$ \diamond$ 例题：P1908 逆序对
$ \diamond$ 代码：
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#define For(i, x, y) for (register int i = x; i &amp;lt;= y; ++i)
#define For_d(i, x, y) for (register int i = x; i &amp;gt;= y; --i)
using namespace std;
const int MAXN = 5e5+5;
int a[MAXN], b[MAXN], c[MAXN], n;
long long s;
char* p;

typedef long long ll;

inline void read(int&amp;amp; x) {
    x = 0;
    while (*p &amp;lt; 48) p++;
    while (*p &amp;gt;= 48) x = (x &amp;lt;&amp;lt; 3) + (x &amp;lt;&amp;lt; 1) + *p - 48, p++;
}

inline void write(ll x) {
    char s[20]; int c=0;
    do {s[c++]=x%10; x/=10; } while(x);
    For_d(i, c-1, 0) putchar_unlocked(s[i] + 48);
}

inline void init() {
    struct stat in;
    fstat(0, &amp;amp;in);
    p = (char*)mmap(0, in.st_size, 1, 2, 0, 0);
}
inline void mdf(int x){while(x&amp;lt;=n) ++c[x],x+=x&amp;amp;-x;}
inline void qry(int x){while(x) s+=1ll*c[x],x^=x&amp;amp;-x;}
inline int cmp(int x, int y) {return b[x] &amp;gt;= b[y];}
int main() {
    init();
	read(n);
	For(i, 1, n) read(b[i]), a[i] = i;
	stable_sort(a+1, a+n+1, cmp);
	For(i, 1, n) mdf(a[i]),qry(a[i]-1);
	write(s);
	return 0;
}



二维树状数组
$ \diamond$ 例题：P4514 上帝造题的七分钟
$ \diamond$ 代码：
待占坑。








线段树


模板线段树
$ \diamond$ 例题：P3372 【模板】线段树 1
$ \diamond$ 代码：
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
#define For(i, x, y) for (register int i = x; i &amp;lt;= y; ++i)
typedef long long ll;
const int MAXN = 1e5;
struct Node {
    int l, r;
    ll sum, add;
};
Node tr[4*MAXN+5];
int n, m, op, L, R, x;

static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
    ll res=0,w=0;
    char c=gc;
    while (!isdigit(c)) w|=c==&#39;-&#39;,c=gc;
    while (isdigit(c)) res=(res&amp;lt;&amp;lt;1)+(res&amp;lt;&amp;lt;3)+(c^48),c=gc;
    if (w) res=-res;
    return res;
}
inline void write(ll x) {
    static int sta[50],top=0;
    if (x&amp;lt;0) putchar(&#39;-&#39;),x=-x;
    do {
        sta[top++]=x%10,x/=10;
    }while (x);
    while (top) putchar(sta[--top]+48);
    putchar(&#39;\n&#39;);
}

inline void __Build(int rt, int l, int r) {
    tr[rt].l = l; tr[rt].r = r;
    if (l == r) {
        ll x = read();
        tr[rt].sum = x;
        return;
    }
    int mid = (l+r)&amp;gt;&amp;gt;1;
    __Build(rt&amp;lt;&amp;lt;1, l, mid);
    __Build(rt&amp;lt;&amp;lt;1|1, mid+1, r);
    tr[rt].sum = tr[rt&amp;lt;&amp;lt;1].sum + tr[rt&amp;lt;&amp;lt;1|1].sum;
}
inline void __Update(int rt, int L, int R, int x) {
    int l = tr[rt].l, r = tr[rt].r;
    if (L &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= R) {
        tr[rt].sum += x*(r-l+1);
        tr[rt].add += x;
        return;
    }
    int len = (r-l+1);
    if (tr[rt].add) {
        tr[rt&amp;lt;&amp;lt;1].add += tr[rt].add;
        tr[rt&amp;lt;&amp;lt;1|1].add += tr[rt].add;
        tr[rt&amp;lt;&amp;lt;1].sum += tr[rt].add*(len-(len&amp;gt;&amp;gt;1));
        tr[rt&amp;lt;&amp;lt;1|1].sum += tr[rt].add*(len&amp;gt;&amp;gt;1);
        tr[rt].add = 0;
    }
    int mid = (l+r)&amp;gt;&amp;gt;1;
    if (L &amp;lt;= mid) __Update(rt&amp;lt;&amp;lt;1, L, R, x);
    if (mid &amp;lt; R) __Update(rt&amp;lt;&amp;lt;1|1, L, R, x);
    tr[rt].sum = tr[rt&amp;lt;&amp;lt;1].sum + tr[rt&amp;lt;&amp;lt;1|1].sum;
}
inline ll __Query(int rt, int L, int R) {
    int l =  tr[rt].l, r = tr[rt].r;
    if (L &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= R) return tr[rt].sum;
    int len = (r-l+1);
    if (tr[rt].add) {
        tr[rt&amp;lt;&amp;lt;1].add += tr[rt].add;
        tr[rt&amp;lt;&amp;lt;1|1].add += tr[rt].add;
        tr[rt&amp;lt;&amp;lt;1].sum += tr[rt].add*(len-(len&amp;gt;&amp;gt;1));
        tr[rt&amp;lt;&amp;lt;1|1].sum += tr[rt].add*(len&amp;gt;&amp;gt;1);
        tr[rt].add = 0;
    }
    ll S = 0;
    int mid = (l+r) &amp;gt;&amp;gt; 1;
    if (L &amp;lt;= mid) S += __Query(rt&amp;lt;&amp;lt;1, L, R);
    if (mid &amp;lt; R) S += __Query(rt&amp;lt;&amp;lt;1|1, L, R);
    return S;
}
int main() {
    n = read(), m = read();
    __Build(1, 1, n);
    For(i, 1, m) {
        op = read();
        if (op == 1) {L = read(); R = read(); x = read(); __Update(1, L, R, x);}
        else {L = read(); R = read(); write(__Query(1, L, R));}
    }
    return 0;
}

$ \diamond$ 例题：P3373 【模板】线段树 2
$ \diamond$ 代码：
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;
#define For(i, x, y) for (register int i = x; i &amp;lt;= y; ++i)
typedef long long ll;
const int MAXN = 1e5;
struct Node {
    int l, r;
    ll mul, add, data;
};
Node tr[MAXN*4 + 5];
ll a[MAXN], n, m, P;

static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;amp;&amp;amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
    ll res=0,w=0;
    char c=gc;
    while (!isdigit(c)) w|=c==&#39;-&#39;,c=gc;
    while (isdigit(c)) res=(res&amp;lt;&amp;lt;1)+(res&amp;lt;&amp;lt;3)+(c^48),c=gc;
    if (w) res=-res;
    return res;
}
inline void write(ll x) {
    static int sta[50],top=0;
    if (x&amp;lt;0) putchar(&#39;-&#39;),x=-x;
    do {
        sta[top++]=x%10,x/=10;
    }while (x);
    while (top) putchar(sta[--top]+48);
    putchar(&#39;\n&#39;);
}

inline void Up(int rt) {tr[rt].data = (tr[rt&amp;lt;&amp;lt;1].data + tr[rt&amp;lt;&amp;lt;1|1].data) % P;}
inline void Build(int rt, int l, int r) {
    tr[rt].l = l; tr[rt].r = r; tr[rt].mul = 1; tr[rt].add = 0;
    if (l == r) {tr[rt].data = a[l]; return;}
    int mid = (l+r)&amp;gt;&amp;gt;1;
    Build(rt &amp;lt;&amp;lt; 1, l, mid);
    Build(rt &amp;lt;&amp;lt; 1 | 1, mid+1, r);
    Up(rt);
}
inline void pushdown(int rt) {
    int L = (rt &amp;lt;&amp;lt; 1), R = (rt &amp;lt;&amp;lt; 1 | 1);
    tr[L].mul *= tr[rt].mul; tr[L].mul %= P;
    tr[L].add *= tr[rt].mul; tr[L].add %= P;
    tr[L].data *= tr[rt].mul; tr[L].data %= P;
    tr[R].mul *= tr[rt].mul; tr[R].mul %= P;
    tr[R].add *= tr[rt].mul; tr[R].add %= P;
    tr[R].data *= tr[rt].mul; tr[R].data %= P;
    tr[rt].mul = 1;
    tr[L].add += tr[rt].add; tr[L].add %= P;
    tr[L].data += tr[rt].add * (tr[L].r-tr[L].l+1); tr[L].data %= P;
    tr[R].add += tr[rt].add; tr[R].add %= P;
    tr[R].data += tr[rt].add * (tr[R].r-tr[R].l+1); tr[R].data %= P;
    tr[rt].add = 0;
}
inline void change_chen(ll l, ll r, ll k, ll rt) {
    int L = tr[rt].l, R = tr[rt].r;
    if (l &amp;lt;= L &amp;amp;&amp;amp; R &amp;lt;= r) {
        tr[rt].data *= k;
        tr[rt].mul *= k;
        tr[rt].add *= k;
        return;
    }
    pushdown(rt);
    int mid = (L+R) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid) change_chen(l, r, k, rt&amp;lt;&amp;lt;1);
    if (mid &amp;lt; r) change_chen(l, r, k, rt&amp;lt;&amp;lt;1|1);
    Up(rt);
}
inline void change_jia(ll l, ll r, ll k, ll rt) {
    int L = tr[rt].l, R = tr[rt].r;
    if (l &amp;lt;= L &amp;amp;&amp;amp; R &amp;lt;= r) {
        tr[rt].add += k;
        tr[rt].data += k*(R-L+1);
        return;
    }
    pushdown(rt);
    int mid = (L+R) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid) change_jia(l, r, k, rt&amp;lt;&amp;lt;1);
    if (mid &amp;lt; r) change_jia(l, r, k, rt&amp;lt;&amp;lt;1|1);
    Up(rt);
}
inline ll Query(int l, int r, int rt) {
    int L = tr[rt].l, R = tr[rt].r;
    if (l &amp;lt;= L &amp;amp;&amp;amp; R &amp;lt;= r) return tr[rt].data;
    pushdown(rt);
    ll S = 0, mid = (L+R) &amp;gt;&amp;gt; 1;
    if (l &amp;lt;= mid) S += Query(l, r, rt &amp;lt;&amp;lt; 1); S %= P;
    if (mid &amp;lt; r) S += Query(l, r, rt &amp;lt;&amp;lt; 1 | 1); S %= P;
    return S;
}
int main() {
    n = read(); m = read(); P = read();
    For(i, 1, n) a[i] = read();
    Build(1, 1, n);
    For(i, 1, m) {
        int op = read();
        if (op == 1) {
            ll x = read(), y = read(), k = read();
            change_chen(x, y, k, 1);
        } else if (op == 2) {
            ll x = read(), y = read(), k = read();
            change_jia(x, y, k, 1);
        } else if (op == 3) {
            ll x = read(), y = read();
            write(Query(x, y, 1));
        }
    }
    return 0;
}

$ \diamond$ 例题：P6242 【模板】线段树 3
$ \diamond$ 代码：
待占坑。



权值线段树
$ \diamond$ 例题：暂无
$ \diamond$ 代码：
待占坑。



动态开点线段树
$ \diamond$ 例题：暂无
$ \diamond$ 代码：
待占坑。



zkw 线段树
$ \diamond$ 例题：暂无
$ \diamond$ 代码：
待占坑。



二维线段树
$ \diamond$ 例题：暂无
$ \diamond$ 代码：
待占坑。



线段树合并
$ \diamond$ 例题：暂无
$ \diamond$ 代码：
待占坑。



可持久化线段树（主席树）


区间第 k 小
⋄\diamond⋄ 例题：暂无
⋄\diamond⋄ 代码：
待占坑。



带修主席树
$ \diamond$ 例题：暂无
$ \diamond$ 代码：
待占坑。









平衡树


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://zch-star.github.io/post/oi-zhi-shi-shu/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://zch-star.github.io/images/avatar.png?v=1614145079725)">
        </div>
        <h1 class="id_card-title">
            zch-star 的博客
        </h1>
        <h2 class="id_card-description">
            『给岁月以文明，而不是给文明以岁月』
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://zch-star.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>