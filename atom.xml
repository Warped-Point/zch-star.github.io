<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zch-star.github.io</id>
    <title>zch-star çš„åšå®¢</title>
    <updated>2021-04-04T02:48:06.748Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zch-star.github.io"/>
    <link rel="self" href="https://zch-star.github.io/atom.xml"/>
    <subtitle>ã€ç»™å²æœˆä»¥æ–‡æ˜ï¼Œè€Œä¸æ˜¯ç»™æ–‡æ˜ä»¥å²æœˆã€</subtitle>
    <logo>https://zch-star.github.io/images/avatar.png</logo>
    <icon>https://zch-star.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zch-star çš„åšå®¢</rights>
    <entry>
        <title type="html"><![CDATA[é¢˜è§£ CF88A ã€Chordã€‘]]></title>
        <id>https://zch-star.github.io/post/ti-jie-cf88a-chord/</id>
        <link href="https://zch-star.github.io/post/ti-jie-cf88a-chord/">
        </link>
        <updated>2021-02-24T04:40:21.000Z</updated>
        <content type="html"><![CDATA[<p>åŸé¢˜é“¾æ¥ï¼š<a href="https://www.luogu.com.cn/problem/CF88A">æ´›è°· CF88A ã€Chordã€‘</a></p>
<h2 id="sol"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">Sol</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></h2>
<p><s>è¿™é“é¢˜æˆ‘è¢«å‘äº†å¥½å‡ æ¬¡</s>ï¼Œé¢˜ç›®ä¸­çš„ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">âˆ£</mi><mi>X</mi><mi>Y</mi><mi mathvariant="normal">âˆ£</mi></mrow><annotation encoding="application/x-tex">|XY|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">âˆ£</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">âˆ£</span></span></span></span> ä¸æ˜¯æŒ‡å®ƒä»¬ä¹˜ç§¯çš„ç»å¯¹å€¼ï¼Œè€Œæ˜¯ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathsize="1.2em"><mstyle mathcolor="red"><mtext mathvariant="monospace">å®ƒä»¬çš„å·®çš„ç»å¯¹å€¼</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\large\color{red}\texttt{å®ƒä»¬çš„å·®çš„ç»å¯¹å€¼}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.733332em;vertical-align:0em;"></span><span class="mord text sizing reset-size6 size7" style="color:red;"><span class="mord texttt cjk_fallback" style="color:red;">å®ƒä»¬çš„å·®çš„ç»å¯¹å€¼</span></span></span></span></span>ï¼</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="monospace">Then</mtext></mrow><annotation encoding="application/x-tex">\texttt{Then}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61111em;vertical-align:0em;"></span><span class="mord text"><span class="mord texttt">Then</span></span></span></span></span>ï¼Œæˆ‘ä»¬å°±å¯ä»¥<s>æ„‰å¿«çš„æ‰“æš´åŠ›äº†</s>ã€‚</p>
<p>è¿˜æœ‰ä¸€ä¸ªå°æ³¨æ„ç‚¹ï¼Œæ¯æ¬¡éƒ½éœ€è¦æ’åºä¸€ä¸‹ï¼Œå½“å®ƒä»¬ä¸º <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>strange</mtext></mrow><annotation encoding="application/x-tex">\text{strange}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">strange</span></span></span></span></span> æ—¶ï¼Œè¦æŠŠç¬¬ä¸€ä¸ªéŸ³ç¬¦æé«˜å…«åº¦ï¼Œä¹Ÿå°±æ˜¯ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">+12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mord">2</span></span></span></span>ï¼Œç„¶åå†æ¥ç€å¾€ä¸‹åˆ¤æ–­ã€‚</p>
<h2 id="code"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Code</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
string gett[13] = {&quot;C&quot;, &quot;C#&quot;, &quot;D&quot;, &quot;D#&quot;, &quot;E&quot;, &quot;F&quot;, &quot;F#&quot;, &quot;G&quot;, &quot;G#&quot;, &quot;A&quot;, &quot;B&quot;, &quot;H&quot;}; //æ€è·¯è·Ÿæ¥¼ä¸Šå·®ä¸å¤šï¼Œæ ¹æ®å­—ç¬¦ä¸²æ’åº
string c1, c2, c3;
int a[4];
int main() {
	cin &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; c3;
	for (int i = 0; i &lt; 13; ++i) { //è½¬ä¸ºæ•°å­—
		if (c1 == gett[i]) a[1] = i;
		if (c2 == gett[i]) a[2] = i;
		if (c3 == gett[i]) a[3] = i;
	}
	for (int i = 1; i &lt;= 3; ++i) {
		sort(a + 1, a + 4); //æ’åº
		if ((abs(a[1] - a[2]) == 4 &amp;&amp; abs(a[2] - a[3]) == 3)) {cout &lt;&lt; &quot;major&quot; &lt;&lt; endl; return 0;} //åˆ¤æ–­ä¸º major
        else if ((abs(a[1] - a[2]) == 3 &amp;&amp; abs(a[2] - a[3]) == 4)) {cout &lt;&lt; &quot;minor&quot; &lt;&lt; endl; return 0;} //åˆ¤æ–­ä¸º minor
		a[1] += 12; //ç¬¬ä¸€ä¸ªéŸ³ç¬¦+=12
	}
	cout &lt;&lt; &quot;strange&quot; &lt;&lt; endl; //strange
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OI çŸ¥è¯†æ ‘]]></title>
        <id>https://zch-star.github.io/post/oi-zhi-shi-shu/</id>
        <link href="https://zch-star.github.io/post/oi-zhi-shi-shu/">
        </link>
        <updated>2021-02-24T04:08:16.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathsize="2.074em"><mstyle mathcolor="RoyalBlue"><mrow><mi mathvariant="normal">ã€</mi><mi mathvariant="script">O</mi><mi mathvariant="script">I</mi><mtext>â€…â€Š</mtext><mi mathvariant="normal">çŸ¥</mi><mi mathvariant="normal">è¯†</mi><mi mathvariant="normal">æ ‘</mi><mi mathvariant="normal">ã€</mi></mrow></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\huge\color{RoyalBlue}\mathcal{ã€OI\thickspaceçŸ¥è¯†æ ‘ã€}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.41722642em;vertical-align:0em;"></span><span class="mord sizing reset-size6 size10" style="color:RoyalBlue;"><span class="mord cjk_fallback" style="color:RoyalBlue;">ã€</span><span class="mord mathcal" style="margin-right:0.02778em;color:RoyalBlue;">O</span><span class="mord mathcal" style="margin-right:0.07382em;color:RoyalBlue;">I</span><span class="mspace" style="color:RoyalBlue;margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback" style="color:RoyalBlue;">çŸ¥</span><span class="mord cjk_fallback" style="color:RoyalBlue;">è¯†</span><span class="mord cjk_fallback" style="color:RoyalBlue;">æ ‘</span><span class="mord cjk_fallback" style="color:RoyalBlue;">ã€</span></span></span></span></span></p>
<hr>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathsize="1.44em"><mstyle mathcolor="LimeGreen"><mrow><mi mathvariant="normal">ä¸€</mi><mi mathvariant="normal">ã€</mi><mi mathvariant="normal">æ•°</mi><mi mathvariant="normal">æ®</mi><mi mathvariant="normal">ç»“</mi><mi mathvariant="normal">æ„</mi></mrow></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\Large\color{LimeGreen}\mathsf{ä¸€ã€æ•°æ®ç»“æ„}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord sizing reset-size6 size8" style="color:LimeGreen;"><span class="mord cjk_fallback" style="color:LimeGreen;">ä¸€</span><span class="mord cjk_fallback" style="color:LimeGreen;">ã€</span><span class="mord cjk_fallback" style="color:LimeGreen;">æ•°</span><span class="mord cjk_fallback" style="color:LimeGreen;">æ®</span><span class="mord cjk_fallback" style="color:LimeGreen;">ç»“</span><span class="mord cjk_fallback" style="color:LimeGreen;">æ„</span></span></span></span></span></p>
<ol>
<li>
<p>æ ˆ</p>
<ul>
<li>
<p>å•è°ƒæ ˆ</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P5788">P5788 ã€æ¨¡æ¿ã€‘å•è°ƒæ ˆ</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;
const int MAXN = 3e6;
int n, top = 0, a[MAXN + 5], f[MAXN + 5], q[MAXN + 5];
int main() {
	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
	for (int i = 1; i &lt;= n; i++) {
		while (top &gt; 0 &amp;&amp; a[q[top]] &lt; a[i]) f[q[top]] = i, top--;
		top++; q[top] = i;
	}
	for (int i = 1; i &lt;= n; i++) cout &lt;&lt; f[i] &lt;&lt; &quot; &quot;;
	return 0;
}
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li>
<p>é˜Ÿåˆ—</p>
<ul>
<li>
<p>ä¼˜å…ˆé˜Ÿåˆ—</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P1090">P1090 [NOIP2004 æé«˜ç»„] åˆå¹¶æœå­</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, x, ans;
priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;
int main() {
	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; i++) cin &gt;&gt; x, q.push(x);
	while (q.size() &gt;= 2){
		int a = q.top(); q.pop();
		int b = q.top(); q.pop();
		ans += a + b;
		q.push(a + b);
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
</li>
<li>
<p>å•è°ƒé˜Ÿåˆ—</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P1440">P1440 æ±‚måŒºé—´å†…çš„æœ€å°å€¼</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, m, a[2000010], head, tail;
struct Node {
	int data, num;
} q[2000010];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
	printf(&quot;0\n&quot;);
	head++, q[head].data = a[1], q[head].num = 1; tail++;
	for (int i = 2; i &lt;= n; i++) {
		while (i - q[head].num &gt; m) head++;
		printf(&quot;%d\n&quot;, q[head].data);
		while (q[tail].data &gt; a[i] &amp;&amp; tail &gt;= head) tail--;
		tail++; q[tail].data = a[i]; q[tail].num = i;
	}
	return 0;
}
</code></pre>
</li>
<li>
<p>åŒç«¯é˜Ÿåˆ—</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P2032">P2032 æ‰«æ</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, m, a[2000010], head, tail;
struct Node {
	int data, num;
} q[2000010];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
	head++, q[head].data = a[1], q[head].num = 1; tail++;
	for (int i = 2; i &lt;= n; i++) {
		while (i - q[head].num &gt;= m) head++;
		while (q[tail].data &lt; a[i] &amp;&amp; tail &gt;= head) tail--;
		tail++; q[tail].data = a[i]; q[tail].num = i;
		if (i &gt;= m) printf(&quot;%d\n&quot;, q[head].data);
	}
	return 0;
}
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li>
<p>å †</p>
<ul>
<li>
<p>äºŒå‰å †</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P1334">P1334 ç‘ç‘çš„æœ¨æ¿</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

int n;
long long ans;
priority_queue&lt; ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; a;

static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
	ll res=0,w=0;
	char c=gc;
	while (!isdigit(c)) w|=c=='-',c=gc;
	while (isdigit(c)) res=(res&lt;&lt;1)+(res&lt;&lt;3)+(c^48),c=gc;
	if (w) res=-res;
	return res;
}

inline void write(ll x) {
	static int sta[50],top=0;
	if (x&lt;0) putchar('-'),x=-x;
	do {
		sta[top++]=x%10,x/=10;
	}while (x);
	while (top) putchar(sta[--top]+48);
	putchar('\n');
}

signed main() {
// 	IOS;
	n = read();
	for (register int i = 1; i &lt;= n; ++i) {
		int k = read();
		a.push(k);
	}
	for (register int i = 1; i &lt; n; ++i) {
		int p, q;
		p = a.top(); a.pop();
		q = a.top(); a.pop();
		ans += p + q;
		a.push(p + q);
	}
	write(ans);
	return 0;
}
</code></pre>
</li>
<li>
<p>å·¦åæ ‘</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P3377">P3377 ã€æ¨¡æ¿ã€‘å·¦åæ ‘ï¼ˆå¯å¹¶å †ï¼‰</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=100010;
int n, m, op, x, y;
int lc[MAXN], rc[MAXN], dist[MAXN], rt[MAXN];
bool tf[MAXN];
struct node
{
    int id, v;
    bool operator&lt;(node x)const{return v==x.v?id&lt;x.id:v&lt;x.v;}
}v[MAXN];
int __Find(int x){return rt[x]==x?x:rt[x]=__Find(rt[x]);}
int __Merge(int x, int y) {
	if (!x || !y) return x + y;
	if (v[y] &lt; v[x]) swap(x, y);
	rc[x] = __Merge(rc[x], y);
    if (dist[lc[x]] &lt; dist[rc[x]]) swap(lc[x], rc[x]);
    dist[x] = dist[rc[x]] + 1;
    return x;
}
int main() {
	dist[0] = -1;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;v[i].v), rt[i] = i, v[i].id = i;
	for (int i = 1; i &lt;= m; i++) {
		scanf(&quot;%d%d&quot;, &amp;op, &amp;x);
		if (op == 1) {
			scanf(&quot;%d&quot;, &amp;y);
			if (tf[x] || tf[y]) continue;
			x = __Find(x); y = __Find(y);
			if (x != y) rt[x] = rt[y] = __Merge(x, y);
		}
		if (op == 2) {
			if (tf[x]) {printf(&quot;-1\n&quot;); continue;}
			x = __Find(x);
			printf(&quot;%d\n&quot;, v[x].v);
			tf[x] = true;
			rt[lc[x]] = rt[rc[x]] = rt[x] = __Merge(lc[x], rc[x]);
			lc[x] = rc[x] = dist[x] = 0;
		}
	}
	return 0;
}
</code></pre>
</li>
<li>
<p>æ–œå †</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P2475">P2475 [SCOI2008]æ–œå †</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li>
<p>å¹¶æŸ¥é›†</p>
<ul>
<li>
<p>æ¨¡æ¿å¹¶æŸ¥é›†</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P1551">P1551 äº²æˆš</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-pascal">var
  f:array[0..10001] of longint;
  n,m,p,i,x,y:longint;

function find(x:longint):longint;
begin
  if f[x]=x then exit(x);
  f[x]:=find(f[x]);
  exit(f[x]);
end;

begin
  readln(n,m,p);
  for i:=1 to n do f[i]:=i;
  for i:=1 to m do
    begin
      readln(x,y);
      x:=find(x);
      y:=find(y);
      f[y]:=x;
    end;
  for i:=1 to p do
    begin
      readln(x,y);
      x:=find(x);
      y:=find(y);
      if x=y then writeln('Yes') else writeln('No');
    end;
end.
</code></pre>
</li>
<li>
<p>å¸¦æƒå¹¶æŸ¥é›†</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P2024">P2024 [NOI2001] é£Ÿç‰©é“¾</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P1525">P1525 [NOIP2010 æé«˜ç»„] å…³æŠ¼ç½ªçŠ¯</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAXN = 1e5+5;
struct Node {
	int a, b, c;
};
int n, m, f[MAXN &lt;&lt; 1];
Node a[MAXN];
inline int __Find(int x) {
	if (f[x] != x) f[x] = __Find(f[x]);
	return f[x];
}

typedef long long ll;
static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
	ll res=0,w=0;
	char c=gc;
	while (!isdigit(c)) w|=c=='-',c=gc;
	while (isdigit(c)) res=(res&lt;&lt;1)+(res&lt;&lt;3)+(c^48),c=gc;
	if (w) res=-res;
	return res;
}
bool cmp(Node a, Node b) {
	return a.c &gt; b.c;
}
int main() {
	n = read(); m = read();
	for (int i = 1; i &lt;= (n &lt;&lt; 1); i++) f[i] = i;
	for (int i = 1; i &lt;= m; i++) a[i].a = read(), a[i].b = read(), a[i].c = read();
	sort(a+1, a+m+1, cmp);
	for (int i = 1; i &lt;= m; i++) {
		int fa = __Find(a[i].a);
		int fb = __Find(a[i].b);
		int ffa = __Find(a[i].a + n);
		int ffb = __Find(a[i].b + n);
		if(fa == fb) {
			printf(&quot;%d\n&quot;, a[i].c);
			return 0;
		}
		f[fa] = ffb;
		f[fb] = ffa;
	}
	puts(&quot;0&quot;);
	return 0;
}
</code></pre>
</li>
<li>
<p>å¯æŒä¹…åŒ–å¹¶æŸ¥é›†</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P3402">P3402 å¯æŒä¹…åŒ–å¹¶æŸ¥é›†</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="4">
<li>
<p>é“¾è¡¨</p>
<ul>
<li>
<p>åŒå‘é“¾è¡¨</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P1160">P1160 é˜Ÿåˆ—å®‰æ’</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
const int MAXN = 1e5+5;
struct Node {int L, R;};
int n, m;
Node a[MAXN];

typedef long long ll;
static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
	ll res=0,w=0;
	char c=gc;
	while (!isdigit(c)) w|=c=='-',c=gc;
	while (isdigit(c)) res=(res&lt;&lt;1)+(res&lt;&lt;3)+(c^48),c=gc;
	if (w) res=-res;
	return res;
}

inline void write(ll x) {
	static int sta[50],top=0;
	if (x&lt;0) putchar('-'),x=-x;
	do {
		sta[top++]=x%10,x/=10;
	}while (x);
	while (top) putchar(sta[--top]+48);
	putchar(' ');
}

inline void __addRight(int x, int pos)  {
	a[x].L = pos;
	a[a[pos].R].L = x;
	a[x].R = a[pos].R;
	a[pos].R = x;
}
inline void __addLeft(int x, int pos) {
	a[x].R = pos;
	a[a[pos].L].R = x;
	a[x].L = a[pos].L;
	a[pos].L = x;
}
inline void __Del(int x) {
	if (a[x].L == -1) return;
	a[a[x].L].R = a[x].R;
	a[a[x].R].L = a[x].L;
	a[x].L = -1;
	a[x].R = -1;
}
inline void __Go() {
	int x = a[0].R;
	while (1) {
		write(x);
		if (a[x].R == -1) break;
		x = a[x].R;
	}
}
inline void __Init() {
	for (int i = 1; i &lt;= n; i++) a[i].L = a[i].R = -1;
	a[1].R = -1; a[1].L = 0; a[0].R = 1;
}
int main() {
	n = read();
	__Init();
	for (int i = 2; i &lt;= n; i++) {
		int x = read(), y = read();
		if (!y) __addLeft(i, x); else __addRight(i, x);
	}
	m = read();
	for (int i = 1; i &lt;= m; i++) {
		int x = read();
		__Del(x);
	}
	__Go();
	return 0;
}
</code></pre>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P1081">P1081 [NOIP2012 æé«˜ç»„] å¼€è½¦æ—…è¡Œ</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
<li>
<p>å—çŠ¶é“¾è¡¨</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P4008">P4008 [NOI2003] æ–‡æœ¬ç¼–è¾‘å™¨</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
char xch,xB[1&lt;&lt;15],*xS=xB,*xTT=xB;
#define getc() (xS==xTT&amp;&amp;(xTT=(xS=xB)+fread(xB,1,1&lt;&lt;15,stdin),xS==xTT)?0:*xS++)
inline int read()
{
    int x=0,f=1;char ch=getc();
    while(ch&lt;'0'|ch&gt;'9'){if(ch=='-')f=-1;ch=getc();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getc();}
    return x*f;
}//ä¸ºäº†ä½¿ç¨‹åºè·‘å¾—æ›´å¿«æ‰€ä½¿ç”¨çš„è¯»å…¥ä¼˜åŒ– 
const int maxn=2e3+10;
struct node{
    int nex,siz;//æ¯ä¸€å—æ•°ç»„çš„åç»§ä»¥åŠå¤§å° 
    char a[maxn&lt;&lt;1];
}b[maxn&lt;&lt;2];
int pool[maxn&lt;&lt;2],cnt,curpos;//å†…å­˜æ± ã€æŒ‡é’ˆä»¥åŠå½“å‰å…‰æ ‡ä½ç½® 
inline int modi(){return pool[cnt++];}//å†…å­˜åˆ†é… 
inline void dele(int x){pool[--cnt]=x;}//å†…å­˜å›æ”¶ 
inline void init()
{
    for(int i=1;i&lt;(maxn&lt;&lt;2);++i) pool[i]=i;//ç»´æŠ¤å†…å­˜æ± ï¼ŒåŠ¨æ€åˆ†é…å›æ”¶å†…å­˜ 
    cnt=1;
    b[0].siz=0,b[0].nex=-1;//æ–°å»ºä¸€ä¸ª0å·èŠ‚ç‚¹ï¼Œæ–¹ä¾¿æ“ä½œ 
}
inline void add(int x,int y,int num,char c[])//åœ¨ç¬¬xå—åæ·»åŠ ä¸€ä¸ªç¼–å·ä¸ºyçš„å—ï¼Œé•¿åº¦ä¸ºnum 
{
    if(y!=-1)
    {
        b[y].nex=b[x].nex,b[y].siz=num;
        memcpy(b[y].a,c,num);
    }
    b[x].nex=y;
}
inline void merge(int x,int y)//å°†ç¬¬xå—å’Œç¬¬yå—åˆå¹¶ 
{
    memcpy(b[x].a+b[x].siz,b[y].a,b[y].siz);
    b[x].siz+=b[y].siz,b[x].nex=b[y].nex;
    dele(y);
}
inline void split(int cur,int pos)//å°†ç¬¬curå—ä»poså¤„åˆ†å‰² 
{
    if(cur==-1||pos==b[cur].siz) return ;
    add(cur,modi(),b[cur].siz-pos,b[cur].a+pos);
    b[cur].siz=pos;
}
inline int pos(int &amp;x)//å¯»æ‰¾å½“å‰å…‰æ ‡æ‰€åœ¨çš„å—å’Œå—å†…ä½ç½® 
{
    int now=0;
    while(now!=-1&amp;&amp;x&gt;b[now].siz) x-=b[now].siz,now=b[now].nex;
    return now;
}
inline void insert(int p,int num,char c[])//åœ¨pä½ç½®ä¹‹åæ’å…¥é•¿åº¦ä¸ºnumçš„å­—ç¬¦ä¸² 
{
    int now=pos(p);
    split(now,p);
    int tot=0,nb,st=now;
    while(tot+maxn&lt;=num)//ç»´æŠ¤å—çŠ¶é“¾è¡¨å¹³è¡¡ 
    {
        nb=modi();
        add(now,nb,maxn,c+tot);
        tot+=maxn;
        now=nb;
    }
    if(num-tot)
        nb=modi(),add(now,nb,num-tot,c+tot);
    if(b[now].siz+b[nb].siz&lt;maxn&amp;&amp;nb!=-1)//ä¸ç”¨å¯¹æ•´ä¸ªé“¾è¡¨è¿›è¡Œåˆ¤æ–­ï¼Œéƒ¨åˆ†maintain 
    	merge(now,nb),nb=b[now].nex;
    if(b[st].siz+b[b[st].nex].siz&lt;maxn&amp;&amp;b[st].nex!=-1)//åŒç† 
    	merge(st,b[st].nex);
//    maintain();
}
inline void erase(int p,int num)//åœ¨pä½ç½®ä¹‹ååˆ é™¤é•¿åº¦ä¸ºnumçš„å­—ç¬¦ä¸²
{
    int now=pos(p);
    split(now,p);
    int nex=b[now].nex;
    while(nex!=-1&amp;&amp;num&gt;b[nex].siz)
        num-=b[nex].siz,nex=b[nex].nex;
    split(nex,num);
    nex=b[nex].nex;
    for(int i=b[now].nex;i!=nex;i=b[now].nex)
        b[now].nex=b[i].nex,dele(i);
    while(b[now].siz+b[nex].siz&lt;maxn&amp;&amp;nex!=-1)//ä¸ç”¨å¯¹æ•´ä¸ªé“¾è¡¨è¿›è¡Œåˆ¤æ–­ï¼Œéƒ¨åˆ†maintain 
    	merge(now,nex),nex=b[now].nex;
//    maintain();
}
char ans[20000000];
inline void get(int p,int num)//è¾“å‡ºpä½ç½®åé•¿åº¦ä¸ºnumçš„å­—ç¬¦ä¸²
{
    int cur=pos(p);
    int tot=b[cur].siz-p;
    if(num&lt;tot) tot=num;
    memcpy(ans,b[cur].a+p,tot);
    int now=b[cur].nex;
    while(now!=-1&amp;&amp;num&gt;=tot+b[now].siz)
    {
        memcpy(ans+tot,b[now].a,b[now].siz);
        tot+=b[now].siz,now=b[now].nex;
    }
    if(num-tot&gt;0&amp;&amp;now!=-1)
        memcpy(ans+tot,b[now].a,num-tot);
    ans[num]='\0';//ä¸ºäº†ä¸æ¸…ç©ºï¼Œç”¨\0ç»“æŸ 
    printf(&quot;%s\n&quot;,ans);
}
inline char opt()
{
	char c=getc();
	while(c!='M'&amp;&amp;c!='I'&amp;&amp;c!='D'&amp;&amp;c!='G'&amp;&amp;c!='P'&amp;&amp;c!='N') c=getc();
	return c;
}//ä¸ºäº†ä¸ä¸è¯»å…¥ä¼˜åŒ–å†²çª 
int main()
{
//	freopen(&quot;3.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;3.ans&quot;,&quot;w&quot;,stdout);
    init();
    int m;

    scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;++i)
    {
        switch(opt())
        {
            case 'M':curpos=read();break;
            case 'I':
                int tmp;
                tmp=read();
                for(int i=0;i&lt;tmp;++i)
                {
                    ans[i]=getc();
                    if(ans[i]&lt;32||ans[i]&gt;126) --i;
                }
                insert(curpos,tmp,ans);
                    break;
            case 'D':
                tmp=read();
                erase(curpos,tmp);
                break;
            case 'G':
                tmp=read();
                get(curpos,tmp);
                break;
            case 'P':--curpos;break;
            case 'N':++curpos;break;
        }
    }
    return 0;
}
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="5">
<li>
<p>æ ‘çŠ¶æ•°ç»„</p>
<ul>
<li>
<p>æ±‚é€†åºå¯¹</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P1908">P1908 é€†åºå¯¹</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#define For(i, x, y) for (register int i = x; i &lt;= y; ++i)
#define For_d(i, x, y) for (register int i = x; i &gt;= y; --i)
using namespace std;
const int MAXN = 5e5+5;
int a[MAXN], b[MAXN], c[MAXN], n;
long long s;
char* p;

typedef long long ll;

inline void read(int&amp; x) {
    x = 0;
    while (*p &lt; 48) p++;
    while (*p &gt;= 48) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + *p - 48, p++;
}

inline void write(ll x) {
    char s[20]; int c=0;
    do {s[c++]=x%10; x/=10; } while(x);
    For_d(i, c-1, 0) putchar_unlocked(s[i] + 48);
}

inline void init() {
    struct stat in;
    fstat(0, &amp;in);
    p = (char*)mmap(0, in.st_size, 1, 2, 0, 0);
}
inline void mdf(int x){while(x&lt;=n) ++c[x],x+=x&amp;-x;}
inline void qry(int x){while(x) s+=1ll*c[x],x^=x&amp;-x;}
inline int cmp(int x, int y) {return b[x] &gt;= b[y];}
int main() {
    init();
	read(n);
	For(i, 1, n) read(b[i]), a[i] = i;
	stable_sort(a+1, a+n+1, cmp);
	For(i, 1, n) mdf(a[i]),qry(a[i]-1);
	write(s);
	return 0;
}
</code></pre>
</li>
<li>
<p>äºŒç»´æ ‘çŠ¶æ•°ç»„</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P4514">P4514 ä¸Šå¸é€ é¢˜çš„ä¸ƒåˆ†é’Ÿ</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="6">
<li>
<p>çº¿æ®µæ ‘</p>
<ul>
<li>
<p>æ¨¡æ¿çº¿æ®µæ ‘</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P3372">P3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
#define For(i, x, y) for (register int i = x; i &lt;= y; ++i)
typedef long long ll;
const int MAXN = 1e5;
struct Node {
    int l, r;
    ll sum, add;
};
Node tr[4*MAXN+5];
int n, m, op, L, R, x;

static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
    ll res=0,w=0;
    char c=gc;
    while (!isdigit(c)) w|=c=='-',c=gc;
    while (isdigit(c)) res=(res&lt;&lt;1)+(res&lt;&lt;3)+(c^48),c=gc;
    if (w) res=-res;
    return res;
}
inline void write(ll x) {
    static int sta[50],top=0;
    if (x&lt;0) putchar('-'),x=-x;
    do {
        sta[top++]=x%10,x/=10;
    }while (x);
    while (top) putchar(sta[--top]+48);
    putchar('\n');
}

inline void __Build(int rt, int l, int r) {
    tr[rt].l = l; tr[rt].r = r;
    if (l == r) {
        ll x = read();
        tr[rt].sum = x;
        return;
    }
    int mid = (l+r)&gt;&gt;1;
    __Build(rt&lt;&lt;1, l, mid);
    __Build(rt&lt;&lt;1|1, mid+1, r);
    tr[rt].sum = tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum;
}
inline void __Update(int rt, int L, int R, int x) {
    int l = tr[rt].l, r = tr[rt].r;
    if (L &lt;= l &amp;&amp; r &lt;= R) {
        tr[rt].sum += x*(r-l+1);
        tr[rt].add += x;
        return;
    }
    int len = (r-l+1);
    if (tr[rt].add) {
        tr[rt&lt;&lt;1].add += tr[rt].add;
        tr[rt&lt;&lt;1|1].add += tr[rt].add;
        tr[rt&lt;&lt;1].sum += tr[rt].add*(len-(len&gt;&gt;1));
        tr[rt&lt;&lt;1|1].sum += tr[rt].add*(len&gt;&gt;1);
        tr[rt].add = 0;
    }
    int mid = (l+r)&gt;&gt;1;
    if (L &lt;= mid) __Update(rt&lt;&lt;1, L, R, x);
    if (mid &lt; R) __Update(rt&lt;&lt;1|1, L, R, x);
    tr[rt].sum = tr[rt&lt;&lt;1].sum + tr[rt&lt;&lt;1|1].sum;
}
inline ll __Query(int rt, int L, int R) {
    int l =  tr[rt].l, r = tr[rt].r;
    if (L &lt;= l &amp;&amp; r &lt;= R) return tr[rt].sum;
    int len = (r-l+1);
    if (tr[rt].add) {
        tr[rt&lt;&lt;1].add += tr[rt].add;
        tr[rt&lt;&lt;1|1].add += tr[rt].add;
        tr[rt&lt;&lt;1].sum += tr[rt].add*(len-(len&gt;&gt;1));
        tr[rt&lt;&lt;1|1].sum += tr[rt].add*(len&gt;&gt;1);
        tr[rt].add = 0;
    }
    ll S = 0;
    int mid = (l+r) &gt;&gt; 1;
    if (L &lt;= mid) S += __Query(rt&lt;&lt;1, L, R);
    if (mid &lt; R) S += __Query(rt&lt;&lt;1|1, L, R);
    return S;
}
int main() {
    n = read(), m = read();
    __Build(1, 1, n);
    For(i, 1, m) {
        op = read();
        if (op == 1) {L = read(); R = read(); x = read(); __Update(1, L, R, x);}
        else {L = read(); R = read(); write(__Query(1, L, R));}
    }
    return 0;
}
</code></pre>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P3373">P3373 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 2</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
#define For(i, x, y) for (register int i = x; i &lt;= y; ++i)
typedef long long ll;
const int MAXN = 1e5;
struct Node {
    int l, r;
    ll mul, add, data;
};
Node tr[MAXN*4 + 5];
ll a[MAXN], n, m, P;

static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline ll read() {
    ll res=0,w=0;
    char c=gc;
    while (!isdigit(c)) w|=c=='-',c=gc;
    while (isdigit(c)) res=(res&lt;&lt;1)+(res&lt;&lt;3)+(c^48),c=gc;
    if (w) res=-res;
    return res;
}
inline void write(ll x) {
    static int sta[50],top=0;
    if (x&lt;0) putchar('-'),x=-x;
    do {
        sta[top++]=x%10,x/=10;
    }while (x);
    while (top) putchar(sta[--top]+48);
    putchar('\n');
}

inline void Up(int rt) {tr[rt].data = (tr[rt&lt;&lt;1].data + tr[rt&lt;&lt;1|1].data) % P;}
inline void Build(int rt, int l, int r) {
    tr[rt].l = l; tr[rt].r = r; tr[rt].mul = 1; tr[rt].add = 0;
    if (l == r) {tr[rt].data = a[l]; return;}
    int mid = (l+r)&gt;&gt;1;
    Build(rt &lt;&lt; 1, l, mid);
    Build(rt &lt;&lt; 1 | 1, mid+1, r);
    Up(rt);
}
inline void pushdown(int rt) {
    int L = (rt &lt;&lt; 1), R = (rt &lt;&lt; 1 | 1);
    tr[L].mul *= tr[rt].mul; tr[L].mul %= P;
    tr[L].add *= tr[rt].mul; tr[L].add %= P;
    tr[L].data *= tr[rt].mul; tr[L].data %= P;
    tr[R].mul *= tr[rt].mul; tr[R].mul %= P;
    tr[R].add *= tr[rt].mul; tr[R].add %= P;
    tr[R].data *= tr[rt].mul; tr[R].data %= P;
    tr[rt].mul = 1;
    tr[L].add += tr[rt].add; tr[L].add %= P;
    tr[L].data += tr[rt].add * (tr[L].r-tr[L].l+1); tr[L].data %= P;
    tr[R].add += tr[rt].add; tr[R].add %= P;
    tr[R].data += tr[rt].add * (tr[R].r-tr[R].l+1); tr[R].data %= P;
    tr[rt].add = 0;
}
inline void change_chen(ll l, ll r, ll k, ll rt) {
    int L = tr[rt].l, R = tr[rt].r;
    if (l &lt;= L &amp;&amp; R &lt;= r) {
        tr[rt].data *= k;
        tr[rt].mul *= k;
        tr[rt].add *= k;
        return;
    }
    pushdown(rt);
    int mid = (L+R) &gt;&gt; 1;
    if (l &lt;= mid) change_chen(l, r, k, rt&lt;&lt;1);
    if (mid &lt; r) change_chen(l, r, k, rt&lt;&lt;1|1);
    Up(rt);
}
inline void change_jia(ll l, ll r, ll k, ll rt) {
    int L = tr[rt].l, R = tr[rt].r;
    if (l &lt;= L &amp;&amp; R &lt;= r) {
        tr[rt].add += k;
        tr[rt].data += k*(R-L+1);
        return;
    }
    pushdown(rt);
    int mid = (L+R) &gt;&gt; 1;
    if (l &lt;= mid) change_jia(l, r, k, rt&lt;&lt;1);
    if (mid &lt; r) change_jia(l, r, k, rt&lt;&lt;1|1);
    Up(rt);
}
inline ll Query(int l, int r, int rt) {
    int L = tr[rt].l, R = tr[rt].r;
    if (l &lt;= L &amp;&amp; R &lt;= r) return tr[rt].data;
    pushdown(rt);
    ll S = 0, mid = (L+R) &gt;&gt; 1;
    if (l &lt;= mid) S += Query(l, r, rt &lt;&lt; 1); S %= P;
    if (mid &lt; r) S += Query(l, r, rt &lt;&lt; 1 | 1); S %= P;
    return S;
}
int main() {
    n = read(); m = read(); P = read();
    For(i, 1, n) a[i] = read();
    Build(1, 1, n);
    For(i, 1, m) {
        int op = read();
        if (op == 1) {
            ll x = read(), y = read(), k = read();
            change_chen(x, y, k, 1);
        } else if (op == 2) {
            ll x = read(), y = read(), k = read();
            change_jia(x, y, k, 1);
        } else if (op == 3) {
            ll x = read(), y = read();
            write(Query(x, y, 1));
        }
    }
    return 0;
}
</code></pre>
<p>$ \diamond$ ä¾‹é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P6242">P6242 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 3</a></p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
<li>
<p>æƒå€¼çº¿æ®µæ ‘</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼šæš‚æ— </p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
<li>
<p>åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼šæš‚æ— </p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
<li>
<p>zkw çº¿æ®µæ ‘</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼šæš‚æ— </p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
<li>
<p>äºŒç»´çº¿æ®µæ ‘</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼šæš‚æ— </p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
<li>
<p>çº¿æ®µæ ‘åˆå¹¶</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼šæš‚æ— </p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
<li>
<p>å¯æŒä¹…åŒ–çº¿æ®µæ ‘ï¼ˆä¸»å¸­æ ‘ï¼‰</p>
<ul>
<li>
<p>åŒºé—´ç¬¬ k å°</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>â‹„</mo></mrow><annotation encoding="application/x-tex">\diamond</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">â‹„</span></span></span></span> ä¾‹é¢˜ï¼šæš‚æ— </p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>â‹„</mo></mrow><annotation encoding="application/x-tex">\diamond</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">â‹„</span></span></span></span> ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
<li>
<p>å¸¦ä¿®ä¸»å¸­æ ‘</p>
<p>$ \diamond$ ä¾‹é¢˜ï¼šæš‚æ— </p>
<p>$ \diamond$ ä»£ç ï¼š</p>
<pre><code class="language-cpp">å¾…å å‘ã€‚
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="7">
<li>å¹³è¡¡æ ‘</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://zch-star.github.io/post/hello-gridea/</id>
        <link href="https://zch-star.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>Windows</strong>ï¼Œ<strong>MacOS</strong> æˆ– <strong>Linux</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>